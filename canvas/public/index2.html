<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Node Kinect2 Client</title>
    <style>
        body,
        html {
            padding: 0;
            margin: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.95);
        }

        #bodyCanvas {
            background: url('rome-540040117dd68.jpg');
        }
    </style>
</head>

<body>
    <canvas id="bodyCanvas" text="victory" size="228"></canvas>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        var socket = io.connect('/');
        const canvas = document.getElementById('bodyCanvas')
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
        const ctx = canvas.getContext("2d")



        var colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff'];
        var background = new Image();
        let backgroundReady = false
        background.addEventListener('load', () => {
            backgroundReady = true
        })
        background.src = "rome-540040117dd68.jpg";

        let shieldReady = false
        let shield = new Image();
        shield.addEventListener('load', () => {
            shieldReady = true
        })
        shield.src = "shield.png";

        


        let mouse = new Mouse(canvas)
        let draw = new Draw(ctx)




        // handstate circle size
        var HANDSIZE = 20;

        // closed hand state color
        var HANDCLOSEDCOLOR = "red";

        // open hand state color
        var HANDOPENCOLOR = "green";

        // lasso hand state color
        var HANDLASSOCOLOR = "blue";

        function updateHandState(handState, jointPoint) {
            switch (handState) {
                case 3:
                    drawHand(jointPoint, HANDCLOSEDCOLOR);
                    break;

                case 2:
                    drawHand(jointPoint, HANDOPENCOLOR);
                    break;

                case 4:
                    drawHand(jointPoint, HANDLASSOCOLOR);
                    break;
            }
        }

        function drawHand(jointPoint, handColor) {
            // draw semi transparent hand cicles
            ctx.globalAlpha = 0.75;
            ctx.beginPath();
            ctx.fillStyle = handColor;
            ctx.arc(jointPoint.depthX * canvas.width, jointPoint.depthY * canvas.height, HANDSIZE, 0, Math.PI * 2, true);
            ctx.fill();
            ctx.closePath();
            ctx.globalAlpha = 1;
        }

        socket.on('bodyFrame', function (bodyFrame) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (backgroundReady)
                ctx.drawImage(background, 0, 0);
            var index = 0;
            bodyFrame.bodies.forEach(function (body) {
                if (body.tracked) {
					/*for (var jointType in body.joints) {
						
						ctx.fillStyle = colors[index];
						ctx.fillRect(joint.depthX * canvas.width, joint.depthY * canvas.height, 10, 10);
					}*/
                    //draw hand states
                    //updateHandState(body.leftHandState, body.joints[7]);
                    updateHandState(body.rightHandState, body.joints[11]);
                    /*cameraX: -0.35769253969192505
cameraY: -0.07199238240718842
cameraZ: 0.6234135627746582
colorX: 0.23137125372886658
colorY: 0.6159010529518127
depthX: 0.09679907560348511
depthY: 0.5932852029800415
jointType: 11
orientationW: 0.6392228007316589
orientationX: 0.45933452248573303
orientationY: 0.5539015531539917
orientationZ: 0.27129146456718445
trackingState: 2*/

                    let joint = body.joints[11];
                   
                    mouse.x = joint.depthX * canvas.width
                    mouse.y = joint.depthY * canvas.height

                    if (shieldReady)
                        ctx.drawImage(shield, mouse.x, mouse.y, HANDSIZE , HANDSIZE *joint.depthY);
                    
                    index++;
                }
            });
        });






        let text = canvas.getAttribute('text');
        let fontSize = canvas.getAttribute('size');


        let pixels = []
        let animation = {
            radius: 4,
            move: 0.25,
            pull: 0.15,
            dampen: 0.95,
            density: 5
        }


        // NOTE: this code is a bit upsidedown


        let particles = []
       

        init()
        step()

        function init() {
            draw.set({
                font: `${fontSize}px monospace`,
                textBaseline: 'middle',
                textAlign: 'center',
                fillStyle: '#FFF'
            })

            draw.clear()
            draw.fillText(canvas.width / 2, canvas.height / 2, text)
            particles = scan(ctx, animation.density)
            for (var particle of particles) {
                particle.sx = particle.x
                particle.sy = particle.y
                particle.ax = Math.random() * 25 - 13
                particle.ay = Math.random() * 25 - 13
            }
        }

        function step() {
            draw.clear()
            window.requestAnimationFrame(step)
            var move = animation.move
            var pull = animation.pull
            var dampen = animation.dampen

            for (var particle of particles) {
                var distance = Math.sqrt(Math.pow(particle.y - mouse.y, 2) + Math.pow(particle.x - mouse.x, 2))
                var push = 1 / distance * 6

                for (var ax of ['x', 'y']) {
                    // Move
                    particle[ax] += particle['a' + ax]
                    // Move random
                    particle['a' + ax] += (Math.random() - 0.5) * move
                    // Pull to start
                    particle['a' + ax] -= Math.sign(particle[ax] - particle['s' + ax]) * pull
                    // Dampen
                    particle['a' + ax] *= dampen
                    // Push from mouse
                    particle['a' + ax] -= Math.sign(mouse[ax] - particle[ax]) * push
                }

                draw.fillCircle(particle.x, particle.y, 4)
            }
        }

        function scan(ctx, density) {
            var imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
            var pixels = []
            var rows = ctx.canvas.height / density
            var cols = ctx.canvas.width / density

            for (var row = 0; row < rows; row++) {
                for (var col = 0; col < cols; col++) {
                    var pixelX = col * density + density / 2
                    var pixelY = row * density + density / 2

                    for (var rp = 0; rp < density; rp++) {
                        for (var rc = 0; rc < density; rc++) {
                            var pixelID = ((row * density + rp) * ctx.canvas.width + (col * density + rc)) * 4
                            var [r, g, b, alpha] = [
                                imageData.data[pixelID],
                                imageData.data[pixelID + 1],
                                imageData.data[pixelID + 2],
                                imageData.data[pixelID + 3]
                            ]

                            if (alpha) {
                                pixels.push({ x: pixelX, y: pixelY, info: { r: r, g: g, b: b, alpha: alpha } })
                                rp = density
                                rc = density
                            }
                        }
                    }
                }
            }
            //console.log('pixels', pixels)
            /*
            for(var i = 0; i < imageData.data.length; i+=4) {
                var x = (i/4) % imageData.width
                var y = Math.floor((i/4)/imageData.width) % imageData.height
                var [r,g,b,alpha] = [imageData.data[i],imageData.data[i+1],imageData.data[i+2], imageData.data[i+3]]
                // Loop all pixels and take the max
                // the block at pixel 0 and density 2 would be [0, 1, 4, 5]
                // Note: if the dpi doesn't line up with the col/row count. ðŸ’€
                // Center the pixel between
                //
                //  -------------------
                //  |  0   1   2   3  |
                //  |  4   5   6   7  |
                //  |  8   9  10  11  |
                //  -------------------
                var block = []
                for(var b = 1; b < density; b++) {
                    r = Math.max(r, imageData.data[i+b])
                    g = Math.max(g, imageData.data[i+b+1])
                    b = Math.max(b, imageData.data[i+b+2])
                    alpha = Math.max(b, imageData.data[i+b+3])
                }
                if(alpha) {
                    pixels.push({ x:x, y:y, r:r, g:g, b:b, a:alpha, i:i })
                }
            }
            */
            return pixels
        }
        // function scan() {
        // 	var points = []
        // 	var x = canvas.width; while(x--) {
        // 		var y = canvas.height; while(y--) {
        // 			var [r,g,b,alpha] = ctx.getImageData(x, y, 1, 1).data
        // 			if(alpha){
        // 				points.push({ x:x, y:y, r:r, g:g, b:b, a:alpha })
        // 			}
        // 		}
        // 	}
        // 	return points
        // }


        function Draw(ctx) {
            this.ctx = ctx
            this.canvas = canvas

            this.set = function (options) {
                for (var option in options) {
                    this.ctx[option] = options[option]
                }
            }
            this.fillRect = function (x, y, width, height) {
                this.ctx.fillRect(x, y, width, height)
            }
            this.strokeRect = function (x, y, width, height) {
                this.ctx.strokeRect(x, y, width, height)
            }
            this.fillCircle = function (x, y, radius) {
                this.ctx.beginPath()
                this.ctx.fillStyle = '#ffff00';
                this.ctx.arc(x, y, radius, 0, Math.PI * 2)
                this.ctx.fill()
            }
            this.strokeCircle = function (x, y, radius) {
                this.ctx.beginPath()
                this.ctx.fillStyle = '#ffff00';
                this.ctx.arc(x, y, radius, 0, Math.PI * 2)
                this.ctx.stroke()
            }
            this.fillText = function (x, y, text) {
                this.ctx.fillText(text, x, y)
            }
            this.strokeText = function (x, y, text) {
                this.ctx.strokeText(text, x, y)
            }
            this.line = function (x1, y1, x2, y2) {
                this.ctx.beginPath()
                this.ctx.moveTo(x1, y1)
                this.ctx.lineTo(x2, y2)
                this.ctx.stroke()
            }
            this.clear = function () {
                //this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
            }
        }

        function Mouse(canvas) {
            this.x = 0
            this.y = 0
            /*this.canvas = canvas
            this.canvas.addEventListener('mousemove', function (e) {
                this.x = e.offsetX
                this.y = e.offsetY
            }.bind(this))
            this.canvas.addEventListener('mouseleave', function (e) {
                this.x = -100
                this.y = -100
            }.bind(this))*/
        }

    </script>
</body>

</html>